# Requirements
## Introduction
Wiper system is the utility project. It is used to clean the wind shield of the car at the front and rear. Wiper works by removing oil,dust,rain water and dirt.That get struck to the wind shield and the arm is provided by the motor.The warm gear is able to generate the force required to move the wipers as fast as they need to move. now a days we have an automatic wiper control when ever we stop wiping in between the process it will automatically comes to initial position this is the new wiper system as behined in the wiper arm.The car wipers that have been available in the present day market are manual systems that work on the principle of manual switching.Our proposed system proposes an automatic wiper system that automatically switches ON the wiper on detection of rain and stops the wiper action when rain stops. This system eases the work of driver by eliminating the manual human intervention for initiating the wiper action, thereby contributing to the comfort driving.
## 4W'S and 1H
## Where :
1. It is attached to moveable arms on the outside of the wind shield.
2. It is connected to a motor that controls the wipers.
## Why :
The main purpose of the wiper system is to clean the wind screen sufficiently to provide suitable visibility at all the times.
## When :
The main purpose is to be clear away from rain and snow from the windshield. While the headlights help you see better at night.
## What :
The main purpose is to clean the windshield of the car at he front and rear. In some cars we have wipers on the rear side.
## How :
1. The main purpose is to be operated by an electric motor which is attached to a worm gear.
2. It transmits the necessa4ry force to a long rod that sets the wiper arms in motion.
## SWOT ANALYSIS
## Strength
1. Decreases the environmental pollution.
2. Decreases the fuel consumption.
3. Increase safety.
4. Capacityincreases under shot gaps.
5. Smootness trafic flow.
## Weekness
1. Limited speed.
2. Capacity decreases under conservactive gaps.
3. Cost is high.
4. Maintaince problem.
5. Can be frustrating at low penetration rates.
## opportunities
1. Enables novel MTM applications.
2. Technology maturity may reduce system cost.
## Threat
1. User acceptance in terms of both purchase intention and frequent activation after purchase.
2. Cost.
3. MTM delayed adaptation.
## High Level Requirements
|HLR|Description|
|---|-----------|
|HLR_1|Hardware materials|
|HLR_2|System control should be proper condition|
|HLR_3|Wind shield should have connectors|
|HLR_4|It requires missionary conditions|
|HLR_5|System shall automatically turn the wiper on when it starts raining|
|HLR_6|System shall detect rain|
## Low Level Requirements
|LLR|Description|
|---|-----------|
|LLR_1|High maintaince is required|
|LLR_2|It consumes more battery|
|LLR_3|When antifreeze washer fluid is used, it can help the wipers|
|LLR_4|System should work thoroughly|
|LLR_5|Rain sensor shall detect the rain|
|LLR_6|This signal shall be processed by microcontroller to turn on the wiper|
|LLR_7|Rain shall be detected by using rain sensor|
|LLR_8|Rain sensor shall work on the principle of using water for completing its circuit|
# Exploring STM32F407 Discovery Board
The main purpose of this project is to get an insight into the STM32F407 Discovery Board, which is an ARM Cortex M4 based Microcontroller. As I started working on STM32F07 Discovery Board, initially it was difficult and confusing to understand and program this microcontroller because understanding internal structures and working of the microcontroller using datasheet of STM32F407VGT MCU is difficult especially if one is a beginner.
# Figure 1 : STM32F407 Discovery Board
![boardddddddddd](https://user-images.githubusercontent.com/101496213/168121345-63dada56-a98d-4fda-ab79-786b1513dd99.png)
# NVIC(Nested vectored interrupt controller)
Interrupts are a common feature supported by almost all microcontrollers. They are typically generated by hardware, for example peripherals or external input pins. When a peripheral or hardware needs service from the processor, this will lead to changes in program flow control outside the normal programmed sequence. Typically, the following sequences would occur:
1. The peripheral asserts an interrupt request to the processor.
2. The currently running task is suspended by the processor.
3. The processor executes an Interrupt Service Routine (ISR) to service the peripheral, and optionally the interrupt request is cleared by software if needed.
4. The processor resumes the previously suspended task. For every interrupt there must be a program associated with it. When an interrupt occurs, this program is executed to perform certain service for the interrupt. This program is usually named as Interrupt Service Routine (ISR) or interrupt handler.

![microcontroller diag](https://user-images.githubusercontent.com/101496213/168121601-10866bba-1d6a-4cd8-9aac-ce719c2a961e.png)

As the above figure shows every Cortex-M4 processor provides a Nested Vectored Interrupt Controller (NVIC) for interrupt handling. NVIC facilitates low-latency exception and interrupts handling, controls power management and implements System Control Registers. The NVIC and the processor core interface are closely coupled, which enables low latency to interrupt processing and efficient processing of late arriving interrupts.
For this microcontroller, the NVIC receives interrupt requests from various sources. In addition to interrupt requests, ther are some other events which need servicing. They are called “exceptions” (which are MCU internally generated). For Cortex-M4 processor, exceptions include resets, software interrupts and hardware interrupts. Each exception has an associated 32-bit vector that stores the memory location where the ISR that handles the exception is located. These vectors are stored in ROM at the beginning of memory. As explained earlier Vector table holds the location of ISR. The Cortex-M4 NVIC supports up to 240 interrupt requests (IRQs), a non-maskable interrupt (NMI), a SysTick timer interrupt and a number of system exceptions. Most of these IRQs are generated by peripherals such as timers, GPIO ports and communication interfaces such as UARTs.

